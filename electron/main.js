const electron = require('electron');
const isDev = require('electron-is-dev');
// Module to control application life.
const { app, BrowserWindow, ipcMain, dialog, shell } = electron;

const path = require('path');
const childProcess = require('child_process');
// Module to read .dbf files generated by MUNIM
// const Parser = require('node-dbf').default;

const JSONfile = require('jsonfile');
// Module to read/write-with-modifications to excel
// const XLSX = require('xlsx-populate');

// Keep a global reference of the window object, if you don't, the window will
// be closed automatically when the JavaScript object is garbage collected.
let mainWindow;

function createWindow() {
  if (isDev) {
    process.env.NODE_ENV = 'development';
  } else {
    process.env.NODE_ENV = 'production';
  }

  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 355,
    height: 440,
    resizable: process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'development',
    maximizable: process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'development',
    icon: path.join(__dirname, 'assets/icons/win/64x64.ico'),
  });
  mainWindow.setMenu(null);
  // and load the index.html of the app.
  const startUrl = process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'production'
    ? `file://${__dirname}/react-build/index.html`
    : process.env.ELECTRON_START_URL || 'http://localhost:3000';

  //mainWindow.loadURL(startUrl);
  const ses = mainWindow.webContents.session;
  ses.setProxy({ proxyRules: 'direct://' }, () => {
    mainWindow.loadURL(startUrl);
    mainWindow.show();
  });

  if (process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'development') {
    // Open the DevTools.
    mainWindow.webContents.openDevTools();

    const installExtension = require('electron-devtools-installer').default;
    const REDUX_DEVTOOLS = require('electron-devtools-installer').REDUX_DEVTOOLS;

    installExtension(REDUX_DEVTOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log('An error occurred: ', err));
  }

  ipcMain.on('get-mac-key-hdd', (event) => {
    require('getmac').getMac((err, macAddress) => {
      if (err) event.sender.send('get-mac-key-hdd-error', err.message);
      else {
        const fileName = `${process.cwd().charAt(0)}:/license.json`;
        JSONfile.readFile(fileName, null, (error, data) => {
          if (error) event.sender.send('get-mac-key-hdd-error', error.message);
          else {
            event.sender.send('got-mac-key-hdd', macAddress, data.key, data.license);
          }
        });
      }
    });
  })

  ipcMain.on('get-mac-address', (event) => {
    require('getmac').getMac((err, macAddress) => {
      if (err) event.sender.send('get-mac-address-error', err.message);
      else event.sender.send('got-mac-address', macAddress);
    });
  });

  ipcMain.on('save-license-file', (event, data) => {
    const fileName = `${process.cwd().charAt(0)}:/license.json`;
    JSONfile.writeFile(fileName, data, {spaces: 4, EOL: '\r\n'}, (err) => {
      if(err) {
        console.error(err);
        event.sender.send('save-license-file-error', err.message);
      } else {
        event.sender.send('license-file-saved');
      }
    });
  });

  // event to create one GST report from multiple .dbf reports
  /* parameters
    * reportName: name of the template file to read from and the same name will be given to output file
    * additionalColumns: columns to add to data before writing - for shifting cells to right
    * startingRowNo: row no. to start writing from
  */
  // ipcMain.on('create-one-file', (event, reportName, additionalColumns = [], startingRowNo = 5) => {
  //   // show dialog to choose .dbf files that user wants to write in GST report
  //   event.sender.send('create-one-file-loading-message', 'Selecting files');
  //   dialog.showOpenDialog({
  //     filters: [
  //         { name: 'CSV Files', extensions: ['csv'] }
  //     ],
  //     properties: ['openFile', 'multiSelections']
  //   }, (fileNames) => {
  //     if (fileNames) {
  //       event.sender.send('create-one-file-loading-message', 'Writing data');
  //       // read the template file
  //       XLSX.fromFileAsync(
  //         process.env.NODE_ENV && process.env.NODE_ENV.toLowerCase() === 'production'
  //          ? path.join(__dirname, `../../sample-files/${reportName}.xlsx`)
  //          : path.join(__dirname, `sample-files/${reportName}.xlsx`)
  //       ).then((workbook) => {
  //         event.sender.send('create-one-file-loading-message', 'writing reports');
  //         let count = 0;
  //         // loop through all the files
  //         fileNames.forEach(fileName => {
  //           // start parsing dbf file
  //           const parser = new Parser(fileName, { encoding: 'utf-8' });
  //           let worksheet = null;
  //           let noOfColumns = 0;
  //           let rowIndex = 0;
  //           parser.on('start', () => {
  //             // reset row no. as new sheet is being written
  //             rowIndex = 0;
  //             // select the sheet to work on
  //             worksheet = workbook.sheet(path.parse(fileName).name.toLowerCase());
  //             if (worksheet) {
  //               // get total columns in the worksheet
  //               noOfColumns = (worksheet.row(3) && worksheet.row(3)._node
  //               && worksheet.row(3)._node.children && worksheet.row(3)._node.children.length
  //               && worksheet.row(3)._node.children.length - 1) || 0;
  //             }
  //           });
  //           parser.on('record', (record) => {
  //             if (worksheet) {
  //               let cells = [...additionalColumns, ...Object.values(record)];
  //               cells.shift();
  //               cells.shift();
  //               let isNull = true;
  //               cells.forEach((cell, columnIndex) => {
  //                 if ((columnIndex + 1) < noOfColumns && cell) {
  //                   isNull = false;
  //                 }
  //               });
  //               if (!isNull) {
  //                 rowIndex = rowIndex + 1;
  //                 cells.forEach((cell, columnIndex) => {
  //                   if ((columnIndex + 1) < noOfColumns) {
  //                     if (!cell || cell === "NaN") cell = "";
  //                     worksheet.row(rowIndex + startingRowNo - 1).cell(columnIndex + 1).value(cell);
  //                   }
  //                 });
  //               }
  //             }
  //           });
  //           parser.on('end', () => {
  //             count = count + 1;
  //             if (count === fileNames.length) {
  //               event.sender.send('create-one-file-loading-message', 'Finishing it up');
  //               workbook.toFileAsync(`D:/${reportName}.xlsx`).then(() => {
  //                 event.sender.send('create-one-file-success', `Successfully created file at D:/${reportName}.xlsx. Click this message to see the file`, `D:\\${reportName}.xlsx`);
  //               }).catch((error) => {
  //                 event.sender.send('create-one-file-error', error.message, `Error writing file. Please make sure that D:/${reportName}.xlsx is closed`);
  //               });
  //             }
  //           });
  //           parser.parse(); 
  //         });
  //       }).catch((err) => {
  //         event.sender.send('create-one-file-error', err.message, 'Error reading template');
  //       });
  //     } else {
  //       event.sender.send('create-one-file-cancelled');
  //     }
  //   });
  // });

  ipcMain.on('create-one-file', (event, reportName, additionalColumns = [], startingRowNo = 5) => {
    event.sender.send('create-one-file-loading-message', 'Selecting files');
    dialog.showOpenDialog({
      filters: [
          { name: 'CSV Files', extensions: ['csv'] }
      ],
      properties: ['openFile', 'multiSelections']
    }, (fileNames) => {
      if (fileNames) {
        const xlsxGenerator = childProcess.fork(require.resolve('./xlsx-generator.js'), [JSON.stringify(fileNames), reportName, JSON.stringify(additionalColumns), JSON.stringify(startingRowNo)]);
        xlsxGenerator.on('message', message => {
          switch(message.type) {
            case 'message':
              event.sender.send('create-one-file-loading-message', message.text);
              break;
            case 'success':
              event.sender.send('create-one-file-success', message.text, message.filePath);
              break;
            case 'error':
              event.sender.send('create-one-file-error', message.text);
              break;
            default:
              event.sender.send('create-one-file-cancelled', message.text);
              break;
          }
        });
        xlsxGenerator.on('error', error => {
          dialog.showErrorBox(error);
          app.quit();
        })
      } else {
        event.sender.send('create-one-file-cancelled');
      }
    });
  });

  ipcMain.on('open-explorer-window', (event, filePath) => {
    shell.showItemInFolder(filePath);
  })

  // Emitted when the window is closed.
  mainWindow.on('closed', function () {
    // Dereference the window object, usually you would store windows
    // in an array if your app supports multi windows, this is the time
    // when you should delete the corresponding element.
    mainWindow = null
  })
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed.
app.on('window-all-closed', function () {
    // On OS X it is common for applications and their menu bar
    // to stay active until the user quits explicitly with Cmd + Q
    if (process.platform !== 'darwin') {
        app.quit()
    }
});

// app.on('activate', function () {
//     // On OS X it's common to re-create a window in the app when the
//     // dock icon is clicked and there are no other windows open.
//     if (mainWindow === null) {
//         createWindow()
//     }
// });
