const electron = require('electron');
// Module to control application life.
const { app, BrowserWindow, ipcMain, dialog, shell } = electron;

const path = require('path');

// Module to read .dbf files generated by MUNIM
const Parser = require('node-dbf').default;

const installExtension = require('electron-devtools-installer').default;
const REDUX_DEVTOOLS = require('electron-devtools-installer').REDUX_DEVTOOLS;

// Module to read/write-with-modifications to excel
const XLSX = require('xlsx-populate');

// Keep a global reference of the window object, if you don't, the window will
// be closed automatically when the JavaScript object is garbage collected.
let mainWindow;

function createWindow() {
    // Create the browser window.
    mainWindow = new BrowserWindow({width: 800, height: 600});
    mainWindow.setMenu(null);
    // and load the index.html of the app.
    console.log(__dirname);
    const startUrl = process.env.ELECTRON_START_URL || 'http://localhost:3000';
    
    //mainWindow.loadURL(startUrl);
    const ses = mainWindow.webContents.session;
        ses.setProxy({ proxyRules: 'direct://' }, () => {
        mainWindow.loadURL(startUrl);
        mainWindow.show();
    });
    // Open the DevTools.
    mainWindow.webContents.openDevTools();

    installExtension(REDUX_DEVTOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log('An error occurred: ', err));

		// event to create one GST report from multiple .dbf reports
		/* parameters
		 * reportName: name of the template file to read from and the same name will be given to output file
		 * additionalColumns: columns to add to data before writing - for shifting cells to right
		 * startingRowNo: row no. to start writing from
		*/
		ipcMain.on('create-one-file', (event, reportName, additionalColumns = [], startingRowNo = 5) => {
      // show dialog to choose .dbf files that user wants to write in GST report
      event.sender.send('create-one-file-loading-message', 'Selecting files');
			dialog.showOpenDialog({
				filters: [
						{ name: 'CSV Files', extensions: ['csv'] }
				],
				properties: ['openFile', 'multiSelections']
			}, (fileNames) => {
				if (fileNames) {
					event.sender.send('create-one-file-loading-message', 'Writing data');
					// read the template file
					XLSX.fromFileAsync(path.join(__dirname, `../sample-files/${reportName}.xlsx`)).then((workbook) => {
            event.sender.send('create-one-file-loading-message', 'writing reports');
            let count = 0;
						// loop through all the files
            fileNames.forEach(fileName => {
              // start parsing dbf file
              const parser = new Parser(fileName, { encoding: 'utf-8' });
              let worksheet = null;
              let noOfColumns = 0;
              let rowIndex = 0;
              parser.on('start', () => {
                // reset row no. as new sheet is being written
                rowIndex = 0;
                // select the sheet to work on
                worksheet = workbook.sheet(path.parse(fileName).name.toLowerCase());
                if (worksheet) {
                  // get total columns in the worksheet
                  noOfColumns = (worksheet.row(3) && worksheet.row(3)._node
                  && worksheet.row(3)._node.children && worksheet.row(3)._node.children.length
                  && worksheet.row(3)._node.children.length - 1) || 0;
                }
              });
              parser.on('record', (record) => {
                if (worksheet) {
                  let cells = [...additionalColumns, ...Object.values(record)];
                  cells.shift();
                  cells.shift();
                  let isNull = true;
                  cells.forEach((cell, columnIndex) => {
                    if ((columnIndex + 1) < noOfColumns && cell) {
                      isNull = false;
                    }
                  });
                  if (!isNull) {
                    rowIndex = rowIndex + 1;
                    cells.forEach((cell, columnIndex) => {
                      if ((columnIndex + 1) < noOfColumns) {
                        if (!cell || cell === "NaN") cell = "";
                        worksheet.row(rowIndex + startingRowNo - 1).cell(columnIndex + 1).value(cell);
                      }
                    });
                  }
                }
              });
              parser.on('end', () => {
                count = count + 1;
                if (count === fileNames.length) {
                  event.sender.send('create-one-file-loading-message', 'Finishing it up');
									workbook.toFileAsync(`D:/${reportName}.xlsx`).then(() => {
										event.sender.send('create-one-file-success', `Successfully created file at D:/${reportName}.xlsx. Click this message to see the file`, `D:\\${reportName}.xlsx`);
									}).catch((error) => {
										event.sender.send('create-one-file-error', error.message, `Error writing file. Please make sure that D:/${reportName}.xlsx is closed`);
									});
                }
              });
              parser.parse(); 
            });
					}).catch((err) => {
						event.sender.send('create-one-file-error', err.message, 'Error reading template');
					});
				} else {
					event.sender.send('create-one-file-cancelled');
				}
			});
		});

    ipcMain.on('open-explorer-window', (event, filePath) => {
      shell.showItemInFolder(filePath);
    })

    // Emitted when the window is closed.
    mainWindow.on('closed', function () {
        // Dereference the window object, usually you would store windows
        // in an array if your app supports multi windows, this is the time
        // when you should delete the corresponding element.
        mainWindow = null
    })
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed.
app.on('window-all-closed', function () {
    // On OS X it is common for applications and their menu bar
    // to stay active until the user quits explicitly with Cmd + Q
    if (process.platform !== 'darwin') {
        app.quit()
    }
});

// app.on('activate', function () {
//     // On OS X it's common to re-create a window in the app when the
//     // dock icon is clicked and there are no other windows open.
//     if (mainWindow === null) {
//         createWindow()
//     }
// });
